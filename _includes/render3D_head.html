<script>

if ( WEBGL.isWebGLAvailable() === false ) {
document.body.appendChild( WEBGL.getWebGLErrorMessage() );
}

var container, stats;
var camera, controls, scene, renderer;

function init(path, model) {
    container = document.getElementById(model);

    /* Camera */
    camera = new THREE.PerspectiveCamera( 70, container.offsetWidth / container.offsetHeight, 2, 1000 );

		camera.position.set( 0, 2.5, 2.5 );


		controls = new THREE.OrbitControls( camera, container );

		controls.target.set( 0, - 0.2, - 0.2 );
		controls.update();

    /* scene */
		scene = new THREE.Scene();
  	var loader = new THREE.RGBELoader().setPath( '/'+path );
  	loader.load( model+'.hdr', function ( texture ) {

      	texture.encoding = THREE.RGBEEncoding;
        texture.minFilter = THREE.NearestFilter;
      	texture.magFilter = THREE.NearestFilter;
      	texture.flipY = true;
        var cubeGenerator = new THREE.EquirectangularToCubeGenerator( texture, { resolution: 1024 } );
        cubeGenerator.update( renderer );
        var pmremGenerator = new THREE.PMREMGenerator( cubeGenerator.renderTarget.texture );
    		pmremGenerator.update( renderer );
    		var pmremCubeUVPacker = new THREE.PMREMCubeUVPacker( pmremGenerator.cubeLods );
    		pmremCubeUVPacker.update( renderer );
    		var envMap = pmremCubeUVPacker.CubeUVRenderTarget.texture;


    		// model
    		var loader = new THREE.GLTFLoader().setPath( '/'+path );
    		loader.load( model+'.gltf', function ( gltf ) {
    			gltf.scene.traverse( function ( child ) {
    				if ( child.isMesh ) {
    					child.material.envMap = envMap;
    				}
    			} );

          //gltf.scene.scale.set( 2, 1, 1 );

    			scene.add( gltf.scene );
    		} );
    		pmremGenerator.dispose();
    		pmremCubeUVPacker.dispose();
    		scene.background = cubeGenerator.renderTarget;
	  } );

  	renderer = new THREE.WebGLRenderer( { antialias: true } );
  	renderer.setPixelRatio( window.devicePixelRatio );
    renderer.setSize(container.offsetWidth, container.offsetHeight );
	  renderer.gammaOutput = true;

	  container.appendChild( renderer.domElement );
	  window.addEventListener( 'resize', onWindowResize, false );

  //  controls.noPan = false;
  //  controls.enableKeys = true;
//    controls.enableRotate = true;
  //  controls.enableZoom = true;
        animate();
			}

      function onWindowResize() {
        camera.aspect = container.offsetWidth / container.offsetHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.offsetWidth, container.offsetHeight);
      }


			function animate() {
				requestAnimationFrame( animate );
				renderer.render( scene, camera );
			}
</script>
