<script>

if ( WEBGL.isWebGLAvailable() === false ) {
document.body.appendChild( WEBGL.getWebGLErrorMessage() );
}

var container, stats;
var camera, controls, scene, renderer;

function init(path, model) {
    container = document.getElementById(model);

    /* Camera */
    camera = new THREE.PerspectiveCamera( 70, container.offsetWidth / container.offsetHeight, 2, 1000 );

		camera.position.set( 0, 2.5, 2.5 );


		controls = new THREE.OrbitControls( camera );
		controls.target.set( 0, - 0.2, - 0.2 );
		controls.update();

    /* scene */
		scene = new THREE.Scene();
  	var loader = new THREE.RGBELoader().setPath( '/'+path );
  	loader.load( model+'.hdr', function ( texture ) {
      	texture.encoding = THREE.RGBEEncoding;
        texture.minFilter = THREE.NearestFilter;
      	texture.magFilter = THREE.NearestFilter;
      	texture.flipY = true;
        var cubeGenerator = new THREE.EquirectangularToCubeGenerator( texture, { resolution: 1024 } );
        cubeGenerator.update( renderer );
        var pmremGenerator = new THREE.PMREMGenerator( cubeGenerator.renderTarget.texture );
    		pmremGenerator.update( renderer );
    		var pmremCubeUVPacker = new THREE.PMREMCubeUVPacker( pmremGenerator.cubeLods );
    		pmremCubeUVPacker.update( renderer );
    		var envMap = pmremCubeUVPacker.CubeUVRenderTarget.texture;


    		// model
    		var loader = new THREE.GLTFLoader().setPath( '/'+path );
    		loader.load( model+'.gltf', function ( gltf ) {
    			gltf.scene.traverse( function ( child ) {
    				if ( child.isMesh ) {
    					child.material.envMap = envMap;
    				}
    			} );

          //gltf.scene.scale.set( 2, 1, 1 );

    			scene.add( gltf.scene );
    		} );
    		pmremGenerator.dispose();
    		pmremCubeUVPacker.dispose();
    		scene.background = cubeGenerator.renderTarget;
	  } );

  	renderer = new THREE.WebGLRenderer( { antialias: true } );
  	renderer.setPixelRatio( window.devicePixelRatio );
    renderer.setSize(container.offsetWidth, container.offsetHeight );
	  renderer.gammaOutput = true;

	  container.appendChild( renderer.domElement );
	  window.addEventListener( 'resize', onWindowResize, false );

    window.addEventListener("mousedown", onMouseDown);
    window.addEventListener("touchstart", onMouseDown);
    window.addEventListener("mouseup", onMouseUp);
    window.addEventListener("touchend", onMouseUp);
    window.addEventListener("mousemove", onMouseMove);
    window.addEventListener("touchmove", onMouseMove);


  //  controls.noPan = false;
    controls.enableKeys = true;
    controls.enableRotate = true;
    controls.enableZoom = true;
        animate();
			}

      function onWindowResize() {
        camera.aspect = container.offsetWidth / container.offsetHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.offsetWidth, container.offsetHeight);
      }



      // マウスを押したとき
      function onMouseDown(event) {
          isMouseDown = true;
      }

      // マウスを動かした時
      function onMouseMove(event) {
          if (isMouseDown) {
              // 3DモデルをX軸とY軸方向に回転させます
              if ( mesh ) {
                  mesh.rotation.y = getMouseX(event)/50;
                  mesh.rotation.x = getMouseY(event)/50;

              }
          }
      }

      // マウスを離したとき
      function onMouseUp(event) {
          isMouseDown = false;
      }

      function getMouseX(event) {
          if (event.type.indexOf("touch") == -1)
              return event.clientX;
          else
              return event.touches[0].clientX;
      }

      function getMouseY(event) {
          if (event.type.indexOf("touch") == -1)
              return event.clientY;
          else
              return event.touches[0].clientY;
      }


			function animate() {
				requestAnimationFrame( animate );
				renderer.render( scene, camera );
			}
</script>
